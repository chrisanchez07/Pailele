/*
** ###################################################################
**     This code is generated by the Device Initialization Tool.
**     It is overwritten during code generation.
**     USER MODIFICATION ARE PRESERVED ONLY INSIDE INTERRUPT SERVICE ROUTINES
**     OR EXPLICITLY MARKED SECTIONS
**
**     Project     : DeviceInitialization
**     Processor   : MC9S08JM60CLDE
**     Version     : Component 01.004, Driver 01.08, CPU db: 3.00.048
**     Datasheet   : MC9S08JM60 Rev. 1 11/2007
**     Date/Time   : 2014-09-19, 12:52, # CodeGen: 1
**     Abstract    :
**         This module contains device initialization code 
**         for selected on-chip peripherals.
**     Contents    :
**         Function "MCU_init" initializes selected peripherals
**
**     Copyright : 1997 - 2012 Freescale, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################
*/

/* MODULE MCUinit */

#include <mc9s08jm60.h>                /* I/O map for MC9S08JM60CLDE */
#include "MCUinit.h"
#include "sensores.h"    /* funciones para muestreo de sensores */


/* Standard ANSI C types */
#ifndef int8_t
typedef signed char int8_t;
#endif
#ifndef int16_t
typedef signed int int16_t;
#endif
#ifndef int32_t
typedef signed long int int32_t;
#endif

#ifndef uint8_t
typedef unsigned char uint8_t;
#endif
#ifndef uint16_t
typedef unsigned int uint16_t;
#endif
#ifndef uint32_t
typedef unsigned long int uint32_t;
#endif

/* User declarations and definitions */
#define LED    PTCD_PTCD4
extern unsigned int kp,kd,di;
extern long int PID,proporcional,integral,derivada,integral_max,derivada_max,velocidad,area,error,error_max,error_ant;
extern long int suma_izq,suma_der;

/* End of user declarations and definitions */


/*
** ===================================================================
**     Method      :  MCU_init (component MC9S08JM60_44)
**
**     Description :
**         Device initialization code for selected peripherals.
** ===================================================================
*/
void MCU_init(void)
{
  /* ### MC9S08JM60_44 "Cpu" init code ... */
  /*  PE initialization code after reset */
  /* Common initialization of the write once registers */
  /* SOPT1: COPT=0,STOPE=0 */
  SOPT1 = 0x13U;                                   
  /* SOPT2: COPCLKS=0,COPW=0,SPI1FE=1,SPI2FE=1,ACIC=0 */
  SOPT2 = 0x06U;                                   
  /* SPMSC1: LVWF=0,LVWACK=0,LVWIE=0,LVDRE=1,LVDSE=1,LVDE=1,BGBE=0 */
  SPMSC1 = 0x1CU;                                   
  /* SPMSC2: LVDV=0,LVWV=0,PPDF=0,PPDACK=0,PPDC=0 */
  SPMSC2 = 0x00U;                                   
  /*  System clock initialization */
  /*lint -save  -e923 Disable MISRA rule (11.3) checking. */
  if (*(unsigned char*far)0xFFAFU != 0xFFU) { /* Test if the device trim value is stored on the specified address */
    MCGTRM = *(unsigned char*far)0xFFAFU; /* Initialize MCGTRM register from a non volatile memory */
    MCGSC = *(unsigned char*far)0xFFAEU; /* Initialize MCGSC register from a non volatile memory */
  }
  /*lint -restore Enable MISRA rule (11.3) checking. */
  /* MCGC2: BDIV=3,RANGE=1,HGO=0,LP=0,EREFS=0,ERCLKEN=1,EREFSTEN=0 */
  MCGC2 = 0xE2U;                       /* Set MCGC2 register */
  /* MCGC1: CLKS=0,RDIV=7,IREFS=0,IRCLKEN=0,IREFSTEN=0 */
  MCGC1 = 0x38U;                       /* Set MCGC1 register */
  /* MCGC3: LOLIE=0,PLLS=0,CME=0,VDIV=1 */
  MCGC3 = 0x01U;                       /* Set MCGC3 register */
  while(MCGSC_IREFST != 0U) {          /* Wait until external reference is selected */
   SRS = 0x55U;                        /* Reset watchdog counter write 55, AA */
   SRS = 0xAAU;
  }
  while(MCGSC_LOCK == 0U) {            /* Wait until FLL is locked */
   SRS = 0x55U;                        /* Reset watchdog counter write 55, AA */
   SRS = 0xAAU;
  }
  while((MCGSC & 0x0CU) != 0x00U) {    /* Wait until FLL clock is selected as a bus clock reference */
   SRS = 0x55U;                        /* Reset watchdog counter write 55, AA */
   SRS = 0xAAU;
  }
  

  /* Common initialization of the CPU registers */
  /* PTFPE: PTFPE5=0,PTFPE4=0 */
  PTFPE &= (unsigned char)~(unsigned char)0x30U;                     
  /* PTBSE: PTBSE5=1,PTBSE4=1,PTBSE3=1,PTBSE2=1,PTBSE1=1,PTBSE0=1 */
  PTBSE |= (unsigned char)0x3FU;                      
  /* PTCSE: PTCSE5=1,PTCSE4=1,PTCSE3=1,PTCSE2=1,PTCSE1=1,PTCSE0=1 */
  PTCSE |= (unsigned char)0x3FU;                      
  /* PTDSE: PTDSE2=1,PTDSE1=1,PTDSE0=1 */
  PTDSE |= (unsigned char)0x07U;                      
  /* PTESE: PTESE7=1,PTESE6=1,PTESE5=1,PTESE4=1,PTESE3=1,PTESE2=1,PTESE1=1,PTESE0=1 */
  PTESE = 0xFFU;                                   
  /* PTFSE: PTFSE5=1,PTFSE4=1,PTFSE1=1,PTFSE0=1 */
  PTFSE |= (unsigned char)0x33U;                      
  /* PTGSE: PTGSE5=1,PTGSE4=1,PTGSE3=1,PTGSE2=1,PTGSE1=1,PTGSE0=1 */
  PTGSE |= (unsigned char)0x3FU;                      
  /* PTBDS: PTBDS7=0,PTBDS6=0,PTBDS5=0,PTBDS4=0,PTBDS3=0,PTBDS2=0,PTBDS1=0,PTBDS0=0 */
  PTBDS = 0x00U;                                   
  /* PTCDS: PTCDS6=0,PTCDS5=0,PTCDS4=1,PTCDS3=0,PTCDS2=0,PTCDS1=0,PTCDS0=0 */
  PTCDS = 0x10U;                                   
  /* PTDDS: PTDDS7=0,PTDDS6=0,PTDDS5=0,PTDDS4=0,PTDDS3=0,PTDDS2=0,PTDDS1=0,PTDDS0=0 */
  PTDDS = 0x00U;                                   
  /* PTEDS: PTEDS7=0,PTEDS6=0,PTEDS5=0,PTEDS4=0,PTEDS3=0,PTEDS2=0,PTEDS1=1,PTEDS0=1 */
  PTEDS = 0x03U;                                   
  /* PTFDS: PTFDS7=0,PTFDS6=0,PTFDS5=0,PTFDS4=0,PTFDS3=0,PTFDS2=0,PTFDS1=0,PTFDS0=1 */
  PTFDS = 0x01U;                                   
  /* PTGDS: PTGDS5=0,PTGDS4=0,PTGDS3=0,PTGDS2=0,PTGDS1=0,PTGDS0=0 */
  PTGDS = 0x00U;                                   
  /* ### Init_GPIO init code */
  /* PTBDD: PTBDD0=0 */
  PTBDD &= (unsigned char)~(unsigned char)0x01U;                     
  /* ### Init_GPIO init code */
  /* PTCPE: PTCPE4=0 */
  PTCPE &= (unsigned char)~(unsigned char)0x10U;                     
  /* PTCDD: PTCDD4=1 */
  PTCDD |= (unsigned char)0x10U;                      
  /* ### Init_GPIO init code */
  /* PTEPE: PTEPE1=0,PTEPE0=0 */
  PTEPE &= (unsigned char)~(unsigned char)0x03U;                     
  /* PTEDD: PTEDD1=1,PTEDD0=1 */
  PTEDD |= (unsigned char)0x03U;                      
  /* ### Init_GPIO init code */
  /* PTFPE: PTFPE1=0,PTFPE0=0 */
  PTFPE &= (unsigned char)~(unsigned char)0x03U;                     
  /* PTFDD: PTFDD1=1,PTFDD0=1 */
  PTFDD |= (unsigned char)0x03U;                      
  /* ### Init_COP init code */
  SRS = 0x55U;                         /* Clear WatchDog counter - first part */
  SRS = 0xAAU;                         /* Clear WatchDog counter - second part */
  /* ### Init_RTC init code */
  /* RTCMOD: RTCMOD=0x3B */
  RTCMOD = 0x3BU;                      /* Set modulo register */
  /* RTCSC: RTIF=1,RTCLKS=1,RTIE=1,RTCPS=8 */
  RTCSC = 0xB8U;                       /* Configure RTC */
  /* ### Init_TPM init code */
  (void)(TPM2C0SC == 0U);              /* Channel 0 int. flag clearing (first part) */
  /* TPM2C0SC: CH0F=0,CH0IE=0,MS0B=1,MS0A=0,ELS0B=1,ELS0A=0 */
  TPM2C0SC = 0x28U;                    /* Int. flag clearing (2nd part) and channel 0 contr. register setting */
  TPM2C0V = 0x64U;                     /* Compare 0 value setting */
  (void)(TPM2C1SC == 0U);              /* Channel 1 int. flag clearing (first part) */
  /* TPM2C1SC: CH1F=0,CH1IE=0,MS1B=1,MS1A=0,ELS1B=1,ELS1A=0 */
  TPM2C1SC = 0x28U;                    /* Int. flag clearing (2nd part) and channel 1 contr. register setting */
  TPM2C1V = 0x64U;                     /* Compare 1 value setting */
  /* TPM2SC: TOF=0,TOIE=0,CPWMS=0,CLKSB=0,CLKSA=0,PS2=0,PS1=0,PS0=0 */
  TPM2SC = 0x00U;                      /* Stop and reset counter */
  TPM2MOD = 0x7FBCU;                   /* Period value setting */
  (void)(TPM2SC == 0U);                /* Overflow int. flag clearing (first part) */
  /* TPM2SC: TOF=0,TOIE=0,CPWMS=0,CLKSB=0,CLKSA=1,PS2=0,PS1=0,PS0=0 */
  TPM2SC = 0x08U;                      /* Int. flag clearing (2nd part) and timer control register setting */
  /* ### Init_ADC init code */
  /* APCTL2: ADPC11=0,ADPC10=0,ADPC9=0,ADPC8=0 */
  APCTL2 = 0x00U;                                   
  /* APCTL1: ADPC7=0,ADPC6=0,ADPC5=0,ADPC4=0,ADPC3=0,ADPC2=0,ADPC1=0,ADPC0=0 */
  APCTL1 = 0x00U;                                   
  /* ADCCFG: ADLPC=0,ADIV1=0,ADIV0=0,ADLSMP=0,MODE1=0,MODE0=1,ADICLK1=0,ADICLK0=0 */
  ADCCFG = 0x04U;                                   
  /* ADCCV: ADCV11=0,ADCV10=0,ADCV9=0,ADCV8=0,ADCV7=0,ADCV6=0,ADCV5=0,ADCV4=0,ADCV3=0,ADCV2=0,ADCV1=0,ADCV0=0 */
  ADCCV = 0x00U;                            
  /* ADCSC2: ADACT=0,ADTRG=0,ACFE=0,ACFGT=0 */
  ADCSC2 = 0x00U;                                   
  /* ADCSC1: COCO=0,AIEN=0,ADCO=0,ADCH4=0,ADCH3=0,ADCH2=1,ADCH1=0,ADCH0=1 */
  ADCSC1 = 0x05U;                                   
  /* ### */
  /*lint -save  -e950 Disable MISRA rule (1.1) checking. */
  asm CLI;                             /* Enable interrupts */
  /*lint -restore Enable MISRA rule (1.1) checking. */

} /*MCU_init*/


/*lint -save  -e765 Disable MISRA rule (8.10) checking. */
/*
** ===================================================================
**     Interrupt handler : isrVrtc_muestreo
**
**     Description : INTERRUPCION DE MUESTREO
**     				CONTROLADOR PID
**     Developer   : Christian 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVrtc_muestreo(void)
{

	
RTCSC_RTIE=0;
LED=0; 
sensores();

if(fuera==0)//El carro se encuentra dentro de el rango de la linea -->Control PID
  { 
  suma_izq=-((sensor_ii*7)/2)-(sensor_i*2)-sensor_fi;		
  suma_der=sensor_fd+(sensor_d*2)+((sensor_dd*4));	  
  error=suma_izq+suma_der;
  proporcional=error; 
  
  if(flag_vuelta==1)//Precaucion en la linea de conteo 
	{
	error=0;
	}
  
  //ALGORITMO DE CONTROL INTEGRAL
 
		
  //la integral se calcula de forma numerica por sumas de Rieman de acuerdo a la formula
  //Area=(error+error_ant)*(delta_t/2)
  //  delta_t=5    [ms] --> divide 400   ----- integral incrementa en  maximo    -->f=200 [Hz]
	//  delta_t=10   [ms] --> divide 200   ----- integral incrementa en  maximo    -->f=100 [Hz]
	//  delta_t=20   [ms] --> divide 100   ----- integral incrementa en  maximo    -->f=50  [Hz] 
	area=(error+error_ant)/di;	
	integral=integral+area;

	if( integral>integral_max)     //Funcion Anti_wind up/down
		{
		integral=integral_max;
		}
	else if (integral<(-integral_max))
		{
		integral=-integral_max; 
		}
	 
   
  //ALGORITMO DE CONTROL DERIVATIVO
  //La derivada se calcula como la pendiente del error
  //  delta_t=5    [ms] --> divide 200    -->f=200 [Hz]
  //  delta_t=10   [ms] --> divide 100    -->f=100 [Hz]
  //  delta_t=20   [ms] --> divide 50    -->f=50  [Hz] 
  derivada=(error-error_ant)/90;  
  
  //funcion wash-out -->Ruidos, derivate-kick

  if(derivada>derivada_max)
	{
	derivada=derivada_max;
	} 
  else if (derivada<(-derivada_max))
	{
	derivada=-derivada_max;
	}
  
  
  
  //Realimentacion del error
  error_ant=error;  
   }

else if (fuera==1) //El carro de salio de la linea-->Algoritmo de correccion
	{
	proporcional=error; 
	area=(error+error_ant)/200;		
	integral=integral-area;

	if( integral>velocidad)     //Funcion Anti_wind up/down --> girar solo una rueda maximo
		{
		integral=velocidad;
		}
	else if (integral<(-velocidad))
		{
		integral=-velocidad; 
		}			   

	error_ant=error;
	} 
 
PID=(integral)+((proporcional*kp)/2)+kd*derivada;  

LED=1;
RTCSC_RTIF=1;	
RTCSC_RTIE=1;		

}
/* end of isrVrtc_muestreo */


/*
** ===================================================================
**     Interrupt handler : isrVadc
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVadc(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVadc */


/*
** ===================================================================
**     Interrupt handler : isrVtpm2ovf
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVtpm2ovf(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVtpm2ovf */


/*
** ===================================================================
**     Interrupt handler : isrVtpm2ch1
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVtpm2ch1(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVtpm2ch1 */


/*
** ===================================================================
**     Interrupt handler : isrVtpm2ch0
**
**     Description :
**         User interrupt service routine. 
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
__interrupt void isrVtpm2ch0(void)
{
  /* Write your interrupt code here ... */

}
/* end of isrVtpm2ch0 */


/*lint -restore Enable MISRA rule (8.10) checking. */

/*lint -save  -e950 Disable MISRA rule (1.1) checking. */
/* Initialization of the CPU registers in FLASH */
/* NVPROT: FPS7=1,FPS6=1,FPS5=1,FPS4=1,FPS3=1,FPS2=1,FPS1=1,FPDIS=1 */
static const unsigned char NVPROT_INIT @0x0000FFBDU = 0xFFU;
/* NVOPT: KEYEN=0,FNORED=1,SEC01=1,SEC00=0 */
static const unsigned char NVOPT_INIT @0x0000FFBFU = 0x7EU;
/*lint -restore Enable MISRA rule (1.1) checking. */



extern near void _Startup(void);

/* Interrupt vector table */
#ifndef UNASSIGNED_ISR
  #define UNASSIGNED_ISR ((void(*near const)(void)) 0xFFFF) /* unassigned interrupt service routine */
#endif

/*lint -save  -e923 Disable MISRA rule (11.3) checking. */
/*lint -save  -e950 Disable MISRA rule (1.1) checking. */
static void (* near const _vect[])(void) @0xFFC4 = { /* Interrupt vector table */
/*lint -restore Enable MISRA rule (1.1) checking. */
         isrVrtc_muestreo,             /* Int.no. 29 Vrtc (at FFC4)                  Used */
         UNASSIGNED_ISR,               /* Int.no. 28 Viic (at FFC6)                  Unassigned */
         UNASSIGNED_ISR,               /* Int.no. 27 Vacmp (at FFC8)                 Unassigned */
         isrVadc,                      /* Int.no. 26 Vadc (at FFCA)                  Used */
         UNASSIGNED_ISR,               /* Int.no. 25 Vkeyboard (at FFCC)             Unassigned */
         UNASSIGNED_ISR,               /* Int.no. 24 Vsci2tx (at FFCE)               Unassigned */
         UNASSIGNED_ISR,               /* Int.no. 23 Vsci2rx (at FFD0)               Unassigned */
         UNASSIGNED_ISR,               /* Int.no. 22 Vsci2err (at FFD2)              Unassigned */
         UNASSIGNED_ISR,               /* Int.no. 21 Vsci1tx (at FFD4)               Unassigned */
         UNASSIGNED_ISR,               /* Int.no. 20 Vsci1rx (at FFD6)               Unassigned */
         UNASSIGNED_ISR,               /* Int.no. 19 Vsci1err (at FFD8)              Unassigned */
         isrVtpm2ovf,                  /* Int.no. 18 Vtpm2ovf (at FFDA)              Used */
         isrVtpm2ch1,                  /* Int.no. 17 Vtpm2ch1 (at FFDC)              Used */
         isrVtpm2ch0,                  /* Int.no. 16 Vtpm2ch0 (at FFDE)              Used */
         UNASSIGNED_ISR,               /* Int.no. 15 Vtpm1ovf (at FFE0)              Unassigned */
         UNASSIGNED_ISR,               /* Int.no. 14 VReserved14 (at FFE2)           Unassigned */
         UNASSIGNED_ISR,               /* Int.no. 13 VReserved13 (at FFE4)           Unassigned */
         UNASSIGNED_ISR,               /* Int.no. 12 Vtpm1ch3 (at FFE6)              Unassigned */
         UNASSIGNED_ISR,               /* Int.no. 11 Vtpm1ch2 (at FFE8)              Unassigned */
         UNASSIGNED_ISR,               /* Int.no. 10 Vtpm1ch1 (at FFEA)              Unassigned */
         UNASSIGNED_ISR,               /* Int.no.  9 Vtpm1ch0 (at FFEC)              Unassigned */
         UNASSIGNED_ISR,               /* Int.no.  8 VReserved (at FFEE)             Unassigned */
         UNASSIGNED_ISR,               /* Int.no.  7 Vusb (at FFF0)                  Unassigned */
         UNASSIGNED_ISR,               /* Int.no.  6 Vspi2 (at FFF2)                 Unassigned */
         UNASSIGNED_ISR,               /* Int.no.  5 Vspi1 (at FFF4)                 Unassigned */
         UNASSIGNED_ISR,               /* Int.no.  4 Vlol (at FFF6)                  Unassigned */
         UNASSIGNED_ISR,               /* Int.no.  3 Vlvd (at FFF8)                  Unassigned */
         UNASSIGNED_ISR,               /* Int.no.  2 Virq (at FFFA)                  Unassigned */
         UNASSIGNED_ISR,               /* Int.no.  1 Vswi (at FFFC)                  Unassigned */
         _Startup                      /* Int.no.  0 Vreset (at FFFE)                Reset vector */
};
/*lint -restore Enable MISRA rule (11.3) checking. */




/* END MCUinit */

/*
** ###################################################################
**
**     This file was created by Processor Expert 10.0 [05.03]
**     for the Freescale HCS08 series of microcontrollers.
**
** ###################################################################
*/
